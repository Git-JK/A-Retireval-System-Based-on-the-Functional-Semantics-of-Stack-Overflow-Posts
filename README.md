# A retrieval system based on Stack Overflow Posts functional semantics
本仓库主要为本科论文《基于Stack Overflow问答帖功能语义的检索系统的设计与实现》的代码实现部分，主要想法为使用动词词组和词组模式提取问答帖标题所包含的显式功能语义，并使用基于Bert的Bertlets模型提取问答帖问题描述和回答所包含的隐式功能语义，并与要查询的问题的显式和隐式功能语义进行匹配，从而进行Stack Overflow问答帖推荐

src中为源代码，baseline中为AnswerBot方法的复现代码，system-front-end为系统前端代码


## 0 想要解决的问题

虽然Stack Overflow能为用户提供一定的服务，使得用户能够提出自己的问题并寻求答案和相关问答帖以获得帮助，但是这样的服务比较有限，而且服务效果并不太好。首先，虽然Stack Overflow为用户提供了问答帖分类功能，但是其分类绝大多数依赖于发起问答帖的用户给自己打上的分类标签，用户在进行问题检索的时候无法精确寻找到与自身问题需求匹配度很高的问答帖。一方面，由于用户编程技术水平以及对Stack Overflow分类标签熟悉程度的不同，用户不一定能在进行问题检索时加入合适的分类标签进行搜索；另一方面，由于问答帖的分类是由发帖用户指定的，用户本身编程技术水平会影响分类准确性，使得问答帖的分类不一定具有准确性，这样用户就有可能检索到与自身问题无关的问答帖，降低用户解决自身编程问题的效率。其次，用户在进行问题检索时，Stack Overflow提供的检索系统并不能开放域的情况，即不在特定领域内进行检索的情况下无法很好地抽取问答帖和要查询的问题这两者的语义进行匹配，导致推荐的问题帖与要查询的问题关联度不高，不能很好地解决用户存在的问题。

本文旨在给出一种更好的方法以抽取问答帖和问题的语义，进行匹配推荐并实现更好的推荐效果。

## 1 数据及数据预处理

使用Stack Overflow的问答帖开源数据集Sotorrent，并且进行以下的预处理：
1. 筛选出Sotorrent数据集中所有的问题帖，并根据每一个问题帖搜索数据集中与其对应的回答帖，形成单独的Stack Overflow问答帖的数据形式，其中包括问题ID、问题标题、问题描述、问题评分、问题分类标签、问题URL、问题对应的回答、被接受回答ID。
2. 对第一步中筛选出的每一个问答帖，将其问题标题、问题描述以及每个回答内容中的代码部分和HTML标签全部去除，仅保留纯文本的部分。除此之外，问答帖中还存在一定的换行标记、双空格符号、单空格符号混用的情况。为了统一格式，本文将问答帖中的换行标记和双空格符号全部替换为单空格符号。

除了预处理之外，根据用户评分等标准，筛选了一部分高质量问答帖作为训练集以保证模型训练数据的质量，并筛选出了正常质量的问答帖作为推荐候选的问答帖数据集$P_{search}$。

## 2 基于Stack Overflow问答帖功能语义的问答帖推荐算法

### 2.1 问答帖显式功能语义特征

对于每个问题q, q都包含了动词、疑问词等问句成分，其中体现问句主要功能性的动词词组能清晰、明确地反映问题q的功能语义。我们选择post中提出的问题Q中体现主要功能性的动词词组以及相关语义成分作为post的显式功能语义，与问题q的显式功能语义，即q中体现主要功能性的动词词组以及相关语义成分，进行匹配度计算，得到一个问题q和问答帖post的显示功能语义匹配度得分$Score_{explicit}$

### 2.2 问答帖隐式功能语义特征

除了作为推荐候选的问答帖中提出的问题Q所表现出的显式功能语义之外，问答帖还包含着与问题Q相关的问题描述$Q_d$以及问题Q的答案a。问题描述和问题答案均为长文本，一方面无法直接使用动词词组和词组模式来抽取功能语义，另一方面仅使用动词词组和词组模式来提取功能语义会导致文本内上下文关联所包含的功能语义丢失。我们使用Bertlets模型来提取问题描述$Q_d$与答案a所蕴含的问答帖隐式功能语义并分别计算与用户想要查询的问题q之间的隐式功能语义匹配得分$Score_{implicit}$

### 2.3 匹配度得分计算

在得到$P_{search}$中每一个问答帖的问题描述$Q_d$与问题q的隐式功能语义匹配得分$Score_{implicit} (q,Q_d)$后，记其中最高的得分为$Score_{max} (Q_d)$；同理得到所有问答帖的被接受答案A与问题q的隐式功能语义匹配得分中的最高得分$Score_{max}  (A)$。给出某个问答帖post与问题q的匹配度计算公式如下：

$Score(q,post)=1/3(Score_emplicit (q,post)+(Score_{implicit} (q,Q_d ))/(Score_{max} (Q_d ) )+(Score_{implici}t (q,A))/(Score_{max}(A)))$
